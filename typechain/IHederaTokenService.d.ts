/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "@ethersproject/contracts";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";

interface IHederaTokenServiceInterface extends ethers.utils.Interface {
  functions: {
    "allowance(address,address,address)": FunctionFragment;
    "approve(address,address,uint256)": FunctionFragment;
    "burnToken(address,int64,int64[])": FunctionFragment;
    "createFungibleToken(tuple,int64,int32)": FunctionFragment;
    "freezeToken(address,address)": FunctionFragment;
    "grantTokenKyc(address,address)": FunctionFragment;
    "mintToken(address,int64,bytes[])": FunctionFragment;
    "pauseToken(address)": FunctionFragment;
    "redirectForToken(address,bytes)": FunctionFragment;
    "revokeTokenKyc(address,address)": FunctionFragment;
    "transferFrom(address,address,address,uint256)": FunctionFragment;
    "transferToken(address,address,address,int64)": FunctionFragment;
    "unfreezeToken(address,address)": FunctionFragment;
    "unpauseToken(address)": FunctionFragment;
    "updateTokenInfo(address,tuple)": FunctionFragment;
    "updateTokenKeys(address,tuple[])": FunctionFragment;
    "wipeTokenAccount(address,address,int64)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "allowance",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "burnToken",
    values: [string, BigNumberish, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "createFungibleToken",
    values: [
      {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "freezeToken",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "grantTokenKyc",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "mintToken",
    values: [string, BigNumberish, BytesLike[]]
  ): string;
  encodeFunctionData(functionFragment: "pauseToken", values: [string]): string;
  encodeFunctionData(
    functionFragment: "redirectForToken",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "revokeTokenKyc",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [string, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferToken",
    values: [string, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "unfreezeToken",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "unpauseToken",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenInfo",
    values: [
      string,
      {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenKeys",
    values: [
      string,
      {
        keyType: BigNumberish;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: BytesLike;
          ECDSA_secp256k1: BytesLike;
          delegatableContractId: string;
        };
      }[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "wipeTokenAccount",
    values: [string, string, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "burnToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createFungibleToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "freezeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "grantTokenKyc",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mintToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pauseToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "redirectForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revokeTokenKyc",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unfreezeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unpauseToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenKeys",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "wipeTokenAccount",
    data: BytesLike
  ): Result;

  events: {};
}

export class IHederaTokenService extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: IHederaTokenServiceInterface;

  functions: {
    allowance(
      token: string,
      owner: string,
      spender: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "allowance(address,address,address)"(
      token: string,
      owner: string,
      spender: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    approve(
      token: string,
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "approve(address,address,uint256)"(
      token: string,
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    burnToken(
      token: string,
      amount: BigNumberish,
      serialNumbers: BigNumberish[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "burnToken(address,int64,int64[])"(
      token: string,
      amount: BigNumberish,
      serialNumbers: BigNumberish[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    createFungibleToken(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    "createFungibleToken((string,string,address,string,bool,int64,bool,tuple[],(int64,address,int64)),int64,int32)"(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    freezeToken(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "freezeToken(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    grantTokenKyc(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "grantTokenKyc(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    mintToken(
      token: string,
      amount: BigNumberish,
      metadata: BytesLike[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "mintToken(address,int64,bytes[])"(
      token: string,
      amount: BigNumberish,
      metadata: BytesLike[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    pauseToken(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "pauseToken(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    redirectForToken(
      token: string,
      encodedFunctionSelector: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "redirectForToken(address,bytes)"(
      token: string,
      encodedFunctionSelector: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    revokeTokenKyc(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "revokeTokenKyc(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    transferFrom(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "transferFrom(address,address,address,uint256)"(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    transferToken(
      token: string,
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "transferToken(address,address,address,int64)"(
      token: string,
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    unfreezeToken(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "unfreezeToken(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    unpauseToken(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "unpauseToken(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    updateTokenInfo(
      token: string,
      tokenInfo: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "updateTokenInfo(address,(string,string,address,string,bool,int64,bool,tuple[],(int64,address,int64)))"(
      token: string,
      tokenInfo: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    updateTokenKeys(
      token: string,
      keys: {
        keyType: BigNumberish;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: BytesLike;
          ECDSA_secp256k1: BytesLike;
          delegatableContractId: string;
        };
      }[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "updateTokenKeys(address,tuple[])"(
      token: string,
      keys: {
        keyType: BigNumberish;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: BytesLike;
          ECDSA_secp256k1: BytesLike;
          delegatableContractId: string;
        };
      }[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    wipeTokenAccount(
      token: string,
      account: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "wipeTokenAccount(address,address,int64)"(
      token: string,
      account: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;
  };

  allowance(
    token: string,
    owner: string,
    spender: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "allowance(address,address,address)"(
    token: string,
    owner: string,
    spender: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  approve(
    token: string,
    spender: string,
    amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "approve(address,address,uint256)"(
    token: string,
    spender: string,
    amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  burnToken(
    token: string,
    amount: BigNumberish,
    serialNumbers: BigNumberish[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "burnToken(address,int64,int64[])"(
    token: string,
    amount: BigNumberish,
    serialNumbers: BigNumberish[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  createFungibleToken(
    token: {
      name: string;
      symbol: string;
      treasury: string;
      memo: string;
      tokenSupplyType: boolean;
      maxSupply: BigNumberish;
      freezeDefault: boolean;
      tokenKeys: {
        keyType: BigNumberish;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: BytesLike;
          ECDSA_secp256k1: BytesLike;
          delegatableContractId: string;
        };
      }[];
      expiry: {
        second: BigNumberish;
        autoRenewAccount: string;
        autoRenewPeriod: BigNumberish;
      };
    },
    initialTotalSupply: BigNumberish,
    decimals: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  "createFungibleToken((string,string,address,string,bool,int64,bool,tuple[],(int64,address,int64)),int64,int32)"(
    token: {
      name: string;
      symbol: string;
      treasury: string;
      memo: string;
      tokenSupplyType: boolean;
      maxSupply: BigNumberish;
      freezeDefault: boolean;
      tokenKeys: {
        keyType: BigNumberish;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: BytesLike;
          ECDSA_secp256k1: BytesLike;
          delegatableContractId: string;
        };
      }[];
      expiry: {
        second: BigNumberish;
        autoRenewAccount: string;
        autoRenewPeriod: BigNumberish;
      };
    },
    initialTotalSupply: BigNumberish,
    decimals: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  freezeToken(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "freezeToken(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  grantTokenKyc(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "grantTokenKyc(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  mintToken(
    token: string,
    amount: BigNumberish,
    metadata: BytesLike[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "mintToken(address,int64,bytes[])"(
    token: string,
    amount: BigNumberish,
    metadata: BytesLike[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  pauseToken(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "pauseToken(address)"(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  redirectForToken(
    token: string,
    encodedFunctionSelector: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "redirectForToken(address,bytes)"(
    token: string,
    encodedFunctionSelector: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  revokeTokenKyc(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "revokeTokenKyc(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  transferFrom(
    token: string,
    from: string,
    to: string,
    amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "transferFrom(address,address,address,uint256)"(
    token: string,
    from: string,
    to: string,
    amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  transferToken(
    token: string,
    sender: string,
    recipient: string,
    amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "transferToken(address,address,address,int64)"(
    token: string,
    sender: string,
    recipient: string,
    amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  unfreezeToken(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "unfreezeToken(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  unpauseToken(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "unpauseToken(address)"(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  updateTokenInfo(
    token: string,
    tokenInfo: {
      name: string;
      symbol: string;
      treasury: string;
      memo: string;
      tokenSupplyType: boolean;
      maxSupply: BigNumberish;
      freezeDefault: boolean;
      tokenKeys: {
        keyType: BigNumberish;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: BytesLike;
          ECDSA_secp256k1: BytesLike;
          delegatableContractId: string;
        };
      }[];
      expiry: {
        second: BigNumberish;
        autoRenewAccount: string;
        autoRenewPeriod: BigNumberish;
      };
    },
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "updateTokenInfo(address,(string,string,address,string,bool,int64,bool,tuple[],(int64,address,int64)))"(
    token: string,
    tokenInfo: {
      name: string;
      symbol: string;
      treasury: string;
      memo: string;
      tokenSupplyType: boolean;
      maxSupply: BigNumberish;
      freezeDefault: boolean;
      tokenKeys: {
        keyType: BigNumberish;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: BytesLike;
          ECDSA_secp256k1: BytesLike;
          delegatableContractId: string;
        };
      }[];
      expiry: {
        second: BigNumberish;
        autoRenewAccount: string;
        autoRenewPeriod: BigNumberish;
      };
    },
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  updateTokenKeys(
    token: string,
    keys: {
      keyType: BigNumberish;
      key: {
        inheritAccountKey: boolean;
        contractId: string;
        ed25519: BytesLike;
        ECDSA_secp256k1: BytesLike;
        delegatableContractId: string;
      };
    }[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "updateTokenKeys(address,tuple[])"(
    token: string,
    keys: {
      keyType: BigNumberish;
      key: {
        inheritAccountKey: boolean;
        contractId: string;
        ed25519: BytesLike;
        ECDSA_secp256k1: BytesLike;
        delegatableContractId: string;
      };
    }[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  wipeTokenAccount(
    token: string,
    account: string,
    amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "wipeTokenAccount(address,address,int64)"(
    token: string,
    account: string,
    amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  callStatic: {
    allowance(
      token: string,
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<{
      responseCode: BigNumber;
      allowance: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    "allowance(address,address,address)"(
      token: string,
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<{
      responseCode: BigNumber;
      allowance: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    approve(
      token: string,
      spender: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "approve(address,address,uint256)"(
      token: string,
      spender: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    burnToken(
      token: string,
      amount: BigNumberish,
      serialNumbers: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      responseCode: BigNumber;
      newTotalSupply: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    "burnToken(address,int64,int64[])"(
      token: string,
      amount: BigNumberish,
      serialNumbers: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      responseCode: BigNumber;
      newTotalSupply: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    createFungibleToken(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      responseCode: BigNumber;
      tokenAddress: string;
      0: BigNumber;
      1: string;
    }>;

    "createFungibleToken((string,string,address,string,bool,int64,bool,tuple[],(int64,address,int64)),int64,int32)"(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      responseCode: BigNumber;
      tokenAddress: string;
      0: BigNumber;
      1: string;
    }>;

    freezeToken(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "freezeToken(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    grantTokenKyc(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "grantTokenKyc(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    mintToken(
      token: string,
      amount: BigNumberish,
      metadata: BytesLike[],
      overrides?: CallOverrides
    ): Promise<{
      responseCode: BigNumber;
      newTotalSupply: BigNumber;
      serialNumbers: BigNumber[];
      0: BigNumber;
      1: BigNumber;
      2: BigNumber[];
    }>;

    "mintToken(address,int64,bytes[])"(
      token: string,
      amount: BigNumberish,
      metadata: BytesLike[],
      overrides?: CallOverrides
    ): Promise<{
      responseCode: BigNumber;
      newTotalSupply: BigNumber;
      serialNumbers: BigNumber[];
      0: BigNumber;
      1: BigNumber;
      2: BigNumber[];
    }>;

    pauseToken(token: string, overrides?: CallOverrides): Promise<BigNumber>;

    "pauseToken(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    redirectForToken(
      token: string,
      encodedFunctionSelector: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      responseCode: BigNumber;
      response: string;
      0: BigNumber;
      1: string;
    }>;

    "redirectForToken(address,bytes)"(
      token: string,
      encodedFunctionSelector: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      responseCode: BigNumber;
      response: string;
      0: BigNumber;
      1: string;
    }>;

    revokeTokenKyc(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "revokeTokenKyc(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferFrom(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "transferFrom(address,address,address,uint256)"(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferToken(
      token: string,
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "transferToken(address,address,address,int64)"(
      token: string,
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unfreezeToken(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "unfreezeToken(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unpauseToken(token: string, overrides?: CallOverrides): Promise<BigNumber>;

    "unpauseToken(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    updateTokenInfo(
      token: string,
      tokenInfo: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "updateTokenInfo(address,(string,string,address,string,bool,int64,bool,tuple[],(int64,address,int64)))"(
      token: string,
      tokenInfo: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    updateTokenKeys(
      token: string,
      keys: {
        keyType: BigNumberish;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: BytesLike;
          ECDSA_secp256k1: BytesLike;
          delegatableContractId: string;
        };
      }[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "updateTokenKeys(address,tuple[])"(
      token: string,
      keys: {
        keyType: BigNumberish;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: BytesLike;
          ECDSA_secp256k1: BytesLike;
          delegatableContractId: string;
        };
      }[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    wipeTokenAccount(
      token: string,
      account: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "wipeTokenAccount(address,address,int64)"(
      token: string,
      account: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {};

  estimateGas: {
    allowance(
      token: string,
      owner: string,
      spender: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "allowance(address,address,address)"(
      token: string,
      owner: string,
      spender: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    approve(
      token: string,
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "approve(address,address,uint256)"(
      token: string,
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    burnToken(
      token: string,
      amount: BigNumberish,
      serialNumbers: BigNumberish[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    "burnToken(address,int64,int64[])"(
      token: string,
      amount: BigNumberish,
      serialNumbers: BigNumberish[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    createFungibleToken(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    "createFungibleToken((string,string,address,string,bool,int64,bool,tuple[],(int64,address,int64)),int64,int32)"(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    freezeToken(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "freezeToken(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    grantTokenKyc(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "grantTokenKyc(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    mintToken(
      token: string,
      amount: BigNumberish,
      metadata: BytesLike[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    "mintToken(address,int64,bytes[])"(
      token: string,
      amount: BigNumberish,
      metadata: BytesLike[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    pauseToken(token: string, overrides?: Overrides): Promise<BigNumber>;

    "pauseToken(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    redirectForToken(
      token: string,
      encodedFunctionSelector: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "redirectForToken(address,bytes)"(
      token: string,
      encodedFunctionSelector: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    revokeTokenKyc(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "revokeTokenKyc(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    transferFrom(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "transferFrom(address,address,address,uint256)"(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    transferToken(
      token: string,
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "transferToken(address,address,address,int64)"(
      token: string,
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    unfreezeToken(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "unfreezeToken(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    unpauseToken(token: string, overrides?: Overrides): Promise<BigNumber>;

    "unpauseToken(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    updateTokenInfo(
      token: string,
      tokenInfo: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      overrides?: Overrides
    ): Promise<BigNumber>;

    "updateTokenInfo(address,(string,string,address,string,bool,int64,bool,tuple[],(int64,address,int64)))"(
      token: string,
      tokenInfo: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      overrides?: Overrides
    ): Promise<BigNumber>;

    updateTokenKeys(
      token: string,
      keys: {
        keyType: BigNumberish;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: BytesLike;
          ECDSA_secp256k1: BytesLike;
          delegatableContractId: string;
        };
      }[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    "updateTokenKeys(address,tuple[])"(
      token: string,
      keys: {
        keyType: BigNumberish;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: BytesLike;
          ECDSA_secp256k1: BytesLike;
          delegatableContractId: string;
        };
      }[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    wipeTokenAccount(
      token: string,
      account: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "wipeTokenAccount(address,address,int64)"(
      token: string,
      account: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    allowance(
      token: string,
      owner: string,
      spender: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "allowance(address,address,address)"(
      token: string,
      owner: string,
      spender: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    approve(
      token: string,
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "approve(address,address,uint256)"(
      token: string,
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    burnToken(
      token: string,
      amount: BigNumberish,
      serialNumbers: BigNumberish[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "burnToken(address,int64,int64[])"(
      token: string,
      amount: BigNumberish,
      serialNumbers: BigNumberish[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    createFungibleToken(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    "createFungibleToken((string,string,address,string,bool,int64,bool,tuple[],(int64,address,int64)),int64,int32)"(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    freezeToken(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "freezeToken(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    grantTokenKyc(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "grantTokenKyc(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    mintToken(
      token: string,
      amount: BigNumberish,
      metadata: BytesLike[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "mintToken(address,int64,bytes[])"(
      token: string,
      amount: BigNumberish,
      metadata: BytesLike[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    pauseToken(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "pauseToken(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    redirectForToken(
      token: string,
      encodedFunctionSelector: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "redirectForToken(address,bytes)"(
      token: string,
      encodedFunctionSelector: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    revokeTokenKyc(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "revokeTokenKyc(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    transferFrom(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "transferFrom(address,address,address,uint256)"(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    transferToken(
      token: string,
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "transferToken(address,address,address,int64)"(
      token: string,
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    unfreezeToken(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "unfreezeToken(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    unpauseToken(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "unpauseToken(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    updateTokenInfo(
      token: string,
      tokenInfo: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "updateTokenInfo(address,(string,string,address,string,bool,int64,bool,tuple[],(int64,address,int64)))"(
      token: string,
      tokenInfo: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: BigNumberish;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: BigNumberish;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: BytesLike;
            ECDSA_secp256k1: BytesLike;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: BigNumberish;
          autoRenewAccount: string;
          autoRenewPeriod: BigNumberish;
        };
      },
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    updateTokenKeys(
      token: string,
      keys: {
        keyType: BigNumberish;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: BytesLike;
          ECDSA_secp256k1: BytesLike;
          delegatableContractId: string;
        };
      }[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "updateTokenKeys(address,tuple[])"(
      token: string,
      keys: {
        keyType: BigNumberish;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: BytesLike;
          ECDSA_secp256k1: BytesLike;
          delegatableContractId: string;
        };
      }[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    wipeTokenAccount(
      token: string,
      account: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "wipeTokenAccount(address,address,int64)"(
      token: string,
      account: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;
  };
}
